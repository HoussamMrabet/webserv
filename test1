#ifndef WEBSERVER_HPP
#define WEBSERVER_HPP

#include <vector>
#include <map>
#include <string>
#include <poll.h>
#include <iostream>
#include <unistd.h>
#include <sys/wait.h>

// Forward declarations
class ServerConf;
class Request;
class Response;

enum ConnectionState {
    READING_REQUEST,
    PROCESSING_REQUEST,
    WRITING_RESPONSE,
    WAITING_FOR_CGI,
    CONNECTION_CLOSED
};

enum ConnectionType {
    LISTEN_SOCKET,
    CLIENT_CONNECTION,
    CGI_PIPE
};

struct ConnectionInfo {
    int fd;
    ConnectionType type;
    ConnectionState state;
    time_t last_activity;
    
    // For client connections
    std::string read_buffer;
    std::string write_buffer;
    size_t write_offset;
    Request* request;
    Response* response;
    
    // For CGI connections
    int parent_connection_fd;  // Which client connection owns this CGI
    pid_t cgi_pid;
    int cgi_input_fd;   // Write to CGI
    int cgi_output_fd;  // Read from CGI
    
    ConnectionInfo() : fd(-1), type(CLIENT_CONNECTION), state(READING_REQUEST), 
                      last_activity(time(NULL)), write_offset(0), request(NULL), 
                      response(NULL), parent_connection_fd(-1), cgi_pid(-1), 
                      cgi_input_fd(-1), cgi_output_fd(-1) {}
    
    ~ConnectionInfo() {
        cleanup();
    }
    
    void cleanup() {
        delete request;
        delete response;
        request = NULL;
        response = NULL;
        
        if (cgi_input_fd != -1) {
            close(cgi_input_fd);
            cgi_input_fd = -1;
        }
        if (cgi_output_fd != -1) {
            close(cgi_output_fd);  
            cgi_output_fd = -1;
        }
        if (cgi_pid != -1) {
            kill(cgi_pid, SIGTERM);
            waitpid(cgi_pid, NULL, WNOHANG);
            cgi_pid = -1;
        }
    }
};

class WebServer {
private:
    ServerConf& server_config;
    std::vector<std::pair<std::string, std::string>> listen_addresses;
    std::vector<struct pollfd> poll_fds;
    std::map<int, ConnectionInfo*> connections;
    
    static const int TIMEOUT_SECONDS = 60;
    static const size_t MAX_CONNECTIONS = 1000;
    
public:
    WebServer(ServerConf& config);
    ~WebServer();
    
    bool start();
    void run();
    
private:
    // Server setup
    bool setupListenSockets();
    void addToPoll(int fd, short events, ConnectionType type);
    void removeFromPoll(int fd);
    
    // Connection management
    bool acceptNewConnection(int listen_fd);
    void closeConnection(int fd);
    void cleanupTimeouts();
    
    // Request/Response handling
    bool handleClientRead(ConnectionInfo* conn);
    bool handleClientWrite(ConnectionInfo* conn);
    bool processRequest(ConnectionInfo* conn);
    
    // CGI handling
    bool startCGI(ConnectionInfo* client_conn);
    bool handleCGIOutput(ConnectionInfo* cgi_conn);
    void finishCGI(ConnectionInfo* cgi_conn);
    
    // Utility
    void updateActivity(ConnectionInfo* conn);
    bool isNonBlockingError(int error);
    ConnectionInfo* findConnectionByFd(int fd);
};

// Implementation

WebServer::WebServer(ServerConf& config) : server_config(config) {
    listen_addresses = config.getListen();
}

WebServer::~WebServer() {
    // Cleanup all connections
    for (std::map<int, ConnectionInfo*>::iterator it = connections.begin(); 
         it != connections.end(); ++it) {
        if (it->second->fd != -1) {
            close(it->second->fd);
        }
        delete it->second;
    }
}

bool WebServer::start() {
    return setupListenSockets();
}

bool WebServer::setupListenSockets() {
    for (std::vector<std::pair<std::string, std::string>>::iterator it = listen_addresses.begin();
         it != listen_addresses.end(); ++it) {
        
        int listen_fd = Socket::StartSocket(it->first, it->second);
        if (listen_fd == -1) {
            std::cerr << "Failed to create listen socket for " << it->first << ":" << it->second << std::endl;
            return false;
        }
        
        addToPoll(listen_fd, POLLIN, LISTEN_SOCKET);
        
        ConnectionInfo* listen_conn = new ConnectionInfo();
        listen_conn->fd = listen_fd;
        listen_conn->type = LISTEN_SOCKET;
        connections[listen_fd] = listen_conn;
        
        std::cout << "Listening on " << it->first << ":" << it->second << std::endl;
    }
    
    std::cout << "Document root: " << server_config.getRoot() << std::endl;
    std::cout << "Press Ctrl-C to quit." << std::endl;
    return true;
}

void WebServer::run() {
    while (true) {
        int poll_result = poll(poll_fds.data(), poll_fds.size(), 1000);
        
        if (poll_result == -1) {
            perror("poll");
            break;
        }
        
        cleanupTimeouts();
        
        if (poll_result == 0) {
            continue; // Timeout, check for cleanup and continue
        }
        
        // Process events - iterate backwards for safe removal
        for (int i = static_cast<int>(poll_fds.size()) - 1; i >= 0; i--) {
            struct pollfd& pfd = poll_fds[i];
            
            if (pfd.revents == 0) continue;
            
            ConnectionInfo* conn = findConnectionByFd(pfd.fd);
            if (!conn) continue;
            
            updateActivity(conn);
            
            // Handle different connection types
            switch (conn->type) {
                case LISTEN_SOCKET:
                    if (pfd.revents & POLLIN) {
                        acceptNewConnection(pfd.fd);
                    }
                    break;
                    
                case CLIENT_CONNECTION:
                    if (pfd.revents & (POLLERR | POLLHUP | POLLNVAL)) {
                        closeConnection(pfd.fd);
                        continue;
                    }
                    
                    if (pfd.revents & POLLIN && conn->state == READING_REQUEST) {
                        if (!handleClientRead(conn)) {
                            closeConnection(pfd.fd);
                            continue;
                        }
                    }
                    
                    if (pfd.revents & POLLOUT && conn->state == WRITING_RESPONSE) {
                        if (!handleClientWrite(conn)) {
                            closeConnection(pfd.fd);
                            continue;
                        }
                    }
                    break;
                    
                case CGI_PIPE:
                    if (pfd.revents & (POLLERR | POLLHUP | POLLNVAL)) {
                        finishCGI(conn);
                        continue;
                    }
                    
                    if (pfd.revents & POLLIN) {
                        if (!handleCGIOutput(conn)) {
                            finishCGI(conn);
                            continue;
                        }
                    }
                    break;
            }
        }
    }
}

bool WebServer::acceptNewConnection(int listen_fd) {
    int client_fd = accept(listen_fd, NULL, NULL);
    if (client_fd == -1) {
        perror("accept");
        return false;
    }
    
    if (connections.size() >= MAX_CONNECTIONS) {
        close(client_fd);
        return false;
    }
    
    // Set non-blocking
    int flags = fcntl(client_fd, F_GETFL, 0);
    fcntl(client_fd, F_SETFL, flags | O_NONBLOCK);
    
    ConnectionInfo* conn = new ConnectionInfo();
    conn->fd = client_fd;
    conn->type = CLIENT_CONNECTION;
    conn->state = READING_REQUEST;
    conn->request = new Request();
    
    connections[client_fd] = conn;
    addToPoll(client_fd, POLLIN, CLIENT_CONNECTION);
    
    return true;
}

bool WebServer::handleClientRead(ConnectionInfo* conn) {
    char buffer[4096];
    ssize_t bytes_read = read(conn->fd, buffer, sizeof(buffer));
    
    if (bytes_read <= 0) {
        if (bytes_read == 0) {
            return false; // Client disconnected
        }
        if (!isNonBlockingError(errno)) {
            return false; // Real error
        }
        return true; // EAGAIN/EWOULDBLOCK, try again later
    }
    
    conn->read_buffer.append(buffer, bytes_read);
    
    // Try to parse the request
    if (conn->request->parseRequest(conn->read_buffer)) {
        conn->state = PROCESSING_REQUEST;
        
        // Remove POLLIN, we're done reading
        poll_fds[findPollIndex(conn->fd)].events &= ~POLLIN;
        
        return processRequest(conn);
    }
    
    return true; // Need more data
}

bool WebServer::processRequest(ConnectionInfo* conn) {
    if (conn->request->isCGI()) {
        return startCGI(conn);
    } else {
        // Handle regular request
        conn->response = new Response();
        
        // Process the request based on method
        if (conn->request->getMethod() == "GET") {
            conn->response->handleGetRequest(*conn->request, server_config);
        } else if (conn->request->getMethod() == "POST") {
            conn->response->handlePostRequest(*conn->request, server_config);
        } else {
            conn->response->setError(405, "Method Not Allowed");
        }
        
        conn->write_buffer = conn->response->buildResponse();
        conn->write_offset = 0;
        conn->state = WRITING_RESPONSE;
        
        // Add POLLOUT event
        int poll_index = findPollIndex(conn->fd);
        poll_fds[poll_index].events |= POLLOUT;
        
        return true;
    }
}

bool WebServer::startCGI(ConnectionInfo* conn) {
    int pipe_in[2], pipe_out[2];
    
    if (pipe(pipe_in) == -1 || pipe(pipe_out) == -1) {
        perror("pipe");
        return false;
    }
    
    pid_t pid = fork();
    if (pid == -1) {
        perror("fork");
        close(pipe_in[0]); close(pipe_in[1]);
        close(pipe_out[0]); close(pipe_out[1]);
        return false;
    }
    
    if (pid == 0) {
        // Child process - execute CGI
        close(pipe_in[1]);  // Close write end of input pipe
        close(pipe_out[0]); // Close read end of output pipe
        
        dup2(pipe_in[0], STDIN_FILENO);
        dup2(pipe_out[1], STDOUT_FILENO);
        dup2(pipe_out[1], STDERR_FILENO);
        
        close(pipe_in[0]);
        close(pipe_out[1]);
        
        // Setup CGI environment and execute
        CGI::setupEnvironmentAndExecute(*conn->request, server_config);
        exit(1); // Should never reach here
    }
    
    // Parent process
    close(pipe_in[0]);  // Close read end of input pipe
    close(pipe_out[1]); // Close write end of output pipe
    
    // Set non-blocking
    int flags = fcntl(pipe_out[0], F_GETFL, 0);
    fcntl(pipe_out[0], F_SETFL, flags | O_NONBLOCK);
    
    // Create CGI connection info
    ConnectionInfo* cgi_conn = new ConnectionInfo();
    cgi_conn->fd = pipe_out[0];
    cgi_conn->type = CGI_PIPE;
    cgi_conn->parent_connection_fd = conn->fd;
    cgi_conn->cgi_pid = pid;
    cgi_conn->cgi_input_fd = pipe_in[1];
    cgi_conn->cgi_output_fd = pipe_out[0];
    
    connections[pipe_out[0]] = cgi_conn;
    addToPoll(pipe_out[0], POLLIN, CGI_PIPE);
    
    // Write request body to CGI if POST
    if (conn->request->getMethod() == "POST" && !conn->request->getBody().empty()) {
        write(pipe_in[1], conn->request->getBody().c_str(), conn->request->getBody().length());
    }
    close(pipe_in[1]); // Close write end, CGI will see EOF
    cgi_conn->cgi_input_fd = -1;
    
    conn->state = WAITING_FOR_CGI;
    return true;
}

bool WebServer::handleCGIOutput(ConnectionInfo* cgi_conn) {
    char buffer[4096];
    ssize_t bytes_read = read(cgi_conn->fd, buffer, sizeof(buffer));
    
    if (bytes_read <= 0) {
        if (bytes_read == 0 || !isNonBlockingError(errno)) {
            finishCGI(cgi_conn);
            return false;
        }
        return true; // EAGAIN, try again later
    }
    
    cgi_conn->read_buffer.append(buffer, bytes_read);
    return true;
}

void WebServer::finishCGI(ConnectionInfo* cgi_conn) {
    ConnectionInfo* client_conn = findConnectionByFd(cgi_conn->parent_connection_fd);
    if (!client_conn) {
        closeConnection(cgi_conn->fd);
        return;
    }
    
    // Wait for CGI process to complete
    int status;
    if (cgi_conn->cgi_pid != -1) {
        waitpid(cgi_conn->cgi_pid, &status, WNOHANG);
    }
    
    // Process CGI output and create response
    client_conn->response = new Response();
    client_conn->response->parseCGIOutput(cgi_conn->read_buffer);
    
    client_conn->write_buffer = client_conn->response->buildResponse();
    client_conn->write_offset = 0;
    client_conn->state = WRITING_RESPONSE;
    
    // Add POLLOUT to client connection
    int poll_index = findPollIndex(client_conn->fd);
    poll_fds[poll_index].events |= POLLOUT;
    
    // Remove CGI connection
    closeConnection(cgi_conn->fd);
}

bool WebServer::handleClientWrite(ConnectionInfo* conn) {
    if (conn->write_buffer.empty() || conn->write_offset >= conn->write_buffer.length()) {
        // Nothing to write or already finished
        closeConnection(conn->fd);
        return false;
    }
    
    const char* data = conn->write_buffer.c_str() + conn->write_offset;
    size_t remaining = conn->write_buffer.length() - conn->write_offset;
    
    ssize_t bytes_written = write(conn->fd, data, remaining);
    
    if (bytes_written <= 0) {
        if (!isNonBlockingError(errno)) {
            return false; // Real error
        }
        return true; // EAGAIN, try again later
    }
    
    conn->write_offset += bytes_written;
    
    if (conn->write_offset >= conn->write_buffer.length()) {
        // Response fully sent
        closeConnection(conn->fd);
        return false;
    }
    
    return true;
}

void WebServer::closeConnection(int fd) {
    ConnectionInfo* conn = findConnectionByFd(fd);
    if (!conn) return;
    
    // If this is a client connection with active CGI, clean up CGI too
    if (conn->type == CLIENT_CONNECTION && conn->state == WAITING_FOR_CGI) {
        for (std::map<int, ConnectionInfo*>::iterator it = connections.begin();
             it != connections.end(); ++it) {
            if (it->second->type == CGI_PIPE && it->second->parent_connection_fd == fd) {
                closeConnection(it->first);
                break;
            }
        }
    }
    
    removeFromPoll(fd);
    close(fd);
    delete conn;
    connections.erase(fd);
}

void WebServer::cleanupTimeouts() {
    time_t now = time(NULL);
    std::vector<int> to_close;
    
    for (std::map<int, ConnectionInfo*>::iterator it = connections.begin();
         it != connections.end(); ++it) {
        ConnectionInfo* conn = it->second;
        
        if (conn->type != LISTEN_SOCKET && 
            now - conn->last_activity > TIMEOUT_SECONDS) {
            to_close.push_back(it->first);
        }
    }
    
    for (std::vector<int>::iterator it = to_close.begin(); it != to_close.end(); ++it) {
        std::cout << "Closing connection " << *it << " due to timeout" << std::endl;
        closeConnection(*it);
    }
}

void WebServer::addToPoll(int fd, short events, ConnectionType type) {
    struct pollfd pfd;
    pfd.fd = fd;
    pfd.events = events;
    pfd.revents = 0;
    poll_fds.push_back(pfd);
}

void WebServer::removeFromPoll(int fd) {
    for (std::vector<struct pollfd>::iterator it = poll_fds.begin();
         it != poll_fds.end(); ++it) {
        if (it->fd == fd) {
            poll_fds.erase(it);
            break;
        }
    }
}

ConnectionInfo* WebServer::findConnectionByFd(int fd) {
    std::map<int, ConnectionInfo*>::iterator it = connections.find(fd);
    return (it != connections.end()) ? it->second : NULL;
}

int WebServer::findPollIndex(int fd) {
    for (size_t i = 0; i < poll_fds.size(); ++i) {
        if (poll_fds[i].fd == fd) {
            return static_cast<int>(i);
        }
    }
    return -1;
}

void WebServer::updateActivity(ConnectionInfo* conn) {
    conn->last_activity = time(NULL);
}

bool WebServer::isNonBlockingError(int error) {
    return (error == EAGAIN || error == EWOULDBLOCK);
}

#endif