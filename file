#ifndef SERVER_HPP
#define SERVER_HPP

#include <vector>
#include <map>
#include <poll.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <fcntl.h>
#include <unistd.h>
#include <iostream>
#include <algorithm>
#include <sstream>
#include <cstdlib>
#include <cerrno>
#include <cstring>
#include "ServerConf.hpp"
#include "Request.hpp"
#include "Response.hpp"

#define MAX_CLIENTS 1000
#define BUFFER_SIZE 65536

// Helper function to convert numbers to string (C++98 compatible)
template<typename T>
std::string toString(T value) {
    std::ostringstream oss;
    oss << value;
    return oss.str();
}

class Server {
private:
    std::vector<ServerConf>             _configs;
    std::vector<struct pollfd>          _poll_fds;
    std::map<int, sockaddr_in>          _listen_sockets;  // fd -> address
    std::map<int, std::vector<int> >    _socket_to_servers; // listen_fd -> server_indices
    std::map<int, int>                  _client_to_listen; // client_fd -> listen_fd
    std::map<int, std::string>          _client_buffers;   // client_fd -> partial_request
    std::map<int, Response>             _client_responses; // client_fd -> response

public:
    Server(const std::vector<ServerConf>& configs);
    ~Server();
    
    void    run();
    
private:
    // Setup methods
    bool    setupListenSockets();
    int     createSocket(const std::string& host, int port);
    bool    setNonBlocking(int fd);
    
    // Poll management
    void    addToPoll(int fd, short events);
    void    removeFromPoll(int fd);
    
    // Connection handling
    void    handleNewConnection(int listen_fd);
    void    handleClientData(int client_fd);
    void    handleClientWrite(int client_fd);
    void    closeClient(int client_fd);
    
    // Request processing
    void    processRequest(int client_fd, const std::string& request);
    ServerConf selectServer(int listen_fd, const std::string& host);
    
    // Utility methods
    bool    isCompleteRequest(const std::string& buffer);
    void    cleanup();
    std::string trim(const std::string& str);
};

Server::Server(const std::vector<ServerConf>& configs) : _configs(configs) {
    if (!setupListenSockets()) {
        throw std::runtime_error("Failed to setup listen sockets");
    }
}

Server::~Server() {
    cleanup();
}

void Server::run() {
    std::cout << "Server started with " << _poll_fds.size() << " listen sockets" << std::endl;
    
    while (true) {
        int poll_count = poll(&_poll_fds[0], _poll_fds.size(), -1);
        
        if (poll_count < 0) {
            perror("poll");
            break;
        }
        
        // Process events (iterate carefully to handle dynamic vector changes)
        for (size_t i = 0; i < _poll_fds.size(); ++i) {
            struct pollfd pfd = _poll_fds[i]; // Copy to avoid issues if vector changes
            
            if (pfd.revents == 0)
                continue;
                
            // Check for errors or hangup
            if (pfd.revents & (POLLERR | POLLHUP | POLLNVAL)) {
                if (_listen_sockets.find(pfd.fd) == _listen_sockets.end()) {
                    // Client socket error
                    closeClient(pfd.fd);
                    --i; // Adjust index since we removed an element
                }
                continue;
            }
            
            // Handle events
            if (pfd.revents & POLLIN) {
                if (_listen_sockets.find(pfd.fd) != _listen_sockets.end()) {
                    // New connection on listen socket
                    handleNewConnection(pfd.fd);
                } else {
                    // Data from client
                    handleClientData(pfd.fd);
                }
            }
            
            if (pfd.revents & POLLOUT) {
                // Ready to write to client
                handleClientWrite(pfd.fd);
            }
        }
    }
}

bool Server::setupListenSockets() {
    std::map<std::pair<std::string, int>, int> address_to_fd;
    
    // Create unique listen sockets for each host:port combination
    for (size_t i = 0; i < _configs.size(); ++i) {
        const std::vector<std::pair<std::string, int> > listens = _configs[i].getListens();
        
        for (size_t j = 0; j < listens.size(); ++j) {
            const std::string host = listens[j].first;
            int port = listens[j].second;
            std::pair<std::string, int> addr_pair = std::make_pair(host, port);
            
            int listen_fd;
            if (address_to_fd.find(addr_pair) == address_to_fd.end()) {
                // Create new socket for this address
                listen_fd = createSocket(host, port);
                if (listen_fd < 0) {
                    std::cerr << "Failed to create socket for " << host << ":" << port << std::endl;
                    return false;
                }
                address_to_fd[addr_pair] = listen_fd;
                addToPoll(listen_fd, POLLIN);
                
                std::cout << "Listening on " << host << ":" << port << " (fd: " << listen_fd << ")" << std::endl;
            } else {
                listen_fd = address_to_fd[addr_pair];
            }
            
            // Map this listen socket to this server config
            _socket_to_servers[listen_fd].push_back(static_cast<int>(i));
        }
    }
    
    return true;
}

int Server::createSocket(const std::string& host, int port) {
    int listen_fd = socket(AF_INET, SOCK_STREAM, 0);
    if (listen_fd < 0) {
        perror("socket");
        return -1;
    }
    
    // Set socket options
    int opt = 1;
    if (setsockopt(listen_fd, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt)) < 0) {
        perror("setsockopt");
        close(listen_fd);
        return -1;
    }
    
    if (!setNonBlocking(listen_fd)) {
        close(listen_fd);
        return -1;
    }
    
    // Setup address
    struct sockaddr_in addr;
    std::memset(&addr, 0, sizeof(addr));
    addr.sin_family = AF_INET;
    addr.sin_port = htons(static_cast<uint16_t>(port));
    
    if (host == "0.0.0.0" || host.empty()) {
        addr.sin_addr.s_addr = INADDR_ANY;
    } else {
        if (inet_pton(AF_INET, host.c_str(), &addr.sin_addr) <= 0) {
            std::cerr << "Invalid address: " << host << std::endl;
            close(listen_fd);
            return -1;
        }
    }
    
    // Bind and listen
    if (bind(listen_fd, (struct sockaddr*)&addr, sizeof(addr)) < 0) {
        perror("bind");
        close(listen_fd);
        return -1;
    }
    
    if (listen(listen_fd, SOMAXCONN) < 0) {
        perror("listen");
        close(listen_fd);
        return -1;
    }
    
    _listen_sockets[listen_fd] = addr;
    return listen_fd;
}

bool Server::setNonBlocking(int fd) {
    int flags = fcntl(fd, F_GETFL, 0);
    if (flags < 0) {
        perror("fcntl F_GETFL");
        return false;
    }
    
    if (fcntl(fd, F_SETFL, flags | O_NONBLOCK) < 0) {
        perror("fcntl F_SETFL");
        return false;
    }
    
    return true;
}

void Server::addToPoll(int fd, short events) {
    struct pollfd pfd;
    pfd.fd = fd;
    pfd.events = events;
    pfd.revents = 0;
    _poll_fds.push_back(pfd);
}

void Server::removeFromPoll(int fd) {
    for (std::vector<struct pollfd>::iterator it = _poll_fds.begin(); it != _poll_fds.end(); ++it) {
        if (it->fd == fd) {
            _poll_fds.erase(it);
            break;
        }
    }
}

void Server::handleNewConnection(int listen_fd) {
    struct sockaddr_in client_addr;
    socklen_t client_len = sizeof(client_addr);
    
    int client_fd = accept(listen_fd, (struct sockaddr*)&client_addr, &client_len);
    if (client_fd < 0) {
        if (errno != EAGAIN && errno != EWOULDBLOCK) {
            perror("accept");
        }
        return;
    }
    
    if (!setNonBlocking(client_fd)) {
        close(client_fd);
        return;
    }
    
    // Check connection limit
    if (_poll_fds.size() >= MAX_CLIENTS) {
        std::cerr << "Maximum clients reached, rejecting connection" << std::endl;
        close(client_fd);
        return;
    }
    
    // Add client to poll
    addToPoll(client_fd, POLLIN);
    _client_to_listen[client_fd] = listen_fd;
    _client_buffers[client_fd] = "";
    
    std::cout << "New connection from " << inet_ntoa(client_addr.sin_addr) 
              << ":" << ntohs(client_addr.sin_port) << " (fd: " << client_fd << ")" << std::endl;
}

void Server::handleClientData(int client_fd) {
    char buffer[BUFFER_SIZE];
    ssize_t bytes_read = recv(client_fd, buffer, sizeof(buffer) - 1, 0);
    
    if (bytes_read <= 0) {
        if (bytes_read == 0) {
            std::cout << "Client " << client_fd << " disconnected" << std::endl;
        } else if (errno != EAGAIN && errno != EWOULDBLOCK) {
            perror("recv");
        }
        closeClient(client_fd);
        return;
    }
    
    buffer[bytes_read] = '\0';
    _client_buffers[client_fd] += buffer;
    
    // Check if we have a complete request
    if (isCompleteRequest(_client_buffers[client_fd])) {
        processRequest(client_fd, _client_buffers[client_fd]);
        _client_buffers[client_fd].clear();
    }
}

void Server::handleClientWrite(int client_fd) {
    std::map<int, Response>::iterator it = _client_responses.find(client_fd);
    if (it == _client_responses.end()) {
        // No response ready, remove POLLOUT
        for (size_t i = 0; i < _poll_fds.size(); ++i) {
            if (_poll_fds[i].fd == client_fd) {
                _poll_fds[i].events = POLLIN;
                break;
            }
        }
        return;
    }
    
    Response response = it->second;
    std::string response_str = response.toString();
    
    ssize_t bytes_sent = send(client_fd, response_str.c_str(), response_str.length(), 0);
    
    if (bytes_sent < 0) {
        if (errno != EAGAIN && errno != EWOULDBLOCK) {
            perror("send");
            closeClient(client_fd);
        }
        return;
    }
    
    // Response sent successfully
    _client_responses.erase(it);
    
    // Check if we should keep the connection alive
    // For simplicity, we'll close after each response
    closeClient(client_fd);
}

void Server::closeClient(int client_fd) {
    close(client_fd);
    removeFromPoll(client_fd);
    
    // Clean up client data
    _client_to_listen.erase(client_fd);
    _client_buffers.erase(client_fd);
    _client_responses.erase(client_fd);
}

void Server::processRequest(int client_fd, const std::string& request_str) {
    try {
        // Parse request
        Request request(request_str);
        
        // Find appropriate server configuration
        int listen_fd = _client_to_listen[client_fd];
        ServerConf server_conf = selectServer(listen_fd, request.getHeader("Host"));
        
        // Process request with the selected server configuration
        Response response;
        response.processRequest(request, server_conf);
        _client_responses[client_fd] = response;
        
        // Set client socket to write mode
        for (size_t i = 0; i < _poll_fds.size(); ++i) {
            if (_poll_fds[i].fd == client_fd) {
                _poll_fds[i].events = POLLOUT;
                break;
            }
        }
        
    } catch (const std::exception& e) {
        std::cerr << "Error processing request: " << e.what() << std::endl;
        
        // Send 400 Bad Request
        Response response;
        response.setStatus(400, "Bad Request");
        response.setBody("<html><body><h1>400 Bad Request</h1></body></html>");
        response.setHeader("Content-Type", "text/html");
        _client_responses[client_fd] = response;
        
        for (size_t i = 0; i < _poll_fds.size(); ++i) {
            if (_poll_fds[i].fd == client_fd) {
                _poll_fds[i].events = POLLOUT;
                break;
            }
        }
    }
}

ServerConf Server::selectServer(int listen_fd, const std::string& host_header) {
    std::map<int, std::vector<int> >::iterator it = _socket_to_servers.find(listen_fd);
    if (it == _socket_to_servers.end()) {
        // Return default server if no mapping found
        if (!_configs.empty()) {
            return _configs[0];
        }
        throw std::runtime_error("No server configuration available");
    }
    
    const std::vector<int> server_indices = it->second;
    
    // Extract hostname from Host header (remove port if present)
    std::string hostname = host_header;
    size_t colon_pos = hostname.find(':');
    if (colon_pos != std::string::npos) {
        hostname = hostname.substr(0, colon_pos);
    }
    hostname = trim(hostname);
    
    // First pass: look for exact server_name match
    for (size_t i = 0; i < server_indices.size(); ++i) {
        const ServerConf conf = _configs[server_indices[i]];
        const std::vector<std::string> server_names = conf.getServerNames();
        
        for (size_t j = 0; j < server_names.size(); ++j) {
            if (server_names[j] == hostname) {
                return conf;
            }
        }
    }
    
    // Second pass: return first server for this listen socket (default server)
    if (!server_indices.empty()) {
        return _configs[server_indices[0]];
    }
    
    // Fallback
    return _configs[0];
}

bool Server::isCompleteRequest(const std::string& buffer) {
    // Simple check for complete HTTP request
    // Look for double CRLF indicating end of headers
    size_t header_end = buffer.find("\r\n\r\n");
    if (header_end == std::string::npos) {
        header_end = buffer.find("\n\n");
        if (header_end == std::string::npos) {
            return false;
        }
    }
    
    // For POST/PUT requests, check if we have the complete body
    size_t content_length_pos = buffer.find("Content-Length:");
    if (content_length_pos != std::string::npos) {
        // Extract content length
        size_t value_start = buffer.find(':', content_length_pos) + 1;
        size_t value_end = buffer.find('\r', value_start);
        if (value_end == std::string::npos) {
            value_end = buffer.find('\n', value_start);
        }
        
        if (value_end != std::string::npos) {
            std::string length_str = buffer.substr(value_start, value_end - value_start);
            length_str = trim(length_str);
            
            int content_length = std::atoi(length_str.c_str());
            size_t body_start = buffer.find("\r\n\r\n");
            if (body_start != std::string::npos) {
                body_start += 4;
            } else {
                body_start = buffer.find("\n\n");
                if (body_start != std::string::npos) {
                    body_start += 2;
                } else {
                    return false;
                }
            }
            
            return static_cast<int>(buffer.length()) >= static_cast<int>(body_start) + content_length;
        }
    }
    
    return true; // No content-length, assume complete
}

void Server::cleanup() {
    // Close all file descriptors
    for (std::map<int, sockaddr_in>::iterator it = _listen_sockets.begin(); 
         it != _listen_sockets.end(); ++it) {
        close(it->first);
    }
    
    for (std::map<int, int>::iterator it = _client_to_listen.begin(); 
         it != _client_to_listen.end(); ++it) {
        close(it->first);
    }
    
    // Maps will be automatically cleaned up by their destructors
}

std::string Server::trim(const std::string& str) {
    size_t start = str.find_first_not_of(" \t\r\n");
    if (start == std::string::npos) {
        return "";
    }
    
    size_t end = str.find_last_not_of(" \t\r\n");
    return str.substr(start, end - start + 1);
}

#endif // SERVER_HPP