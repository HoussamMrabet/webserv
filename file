#ifndef WEBSERV_HPP
#define WEBSERV_HPP

#include <vector>
#include <map>
#include <poll.h>
#include <unistd.h>
#include <iostream>
#include "ServerConf.hpp"
#include "Connection.hpp"
#include "Socket.hpp"

class WebServ {
public:
    static bool _runServer;
    
private:
    ServerConf& _server;
    std::vector<struct pollfd> _pollfds;
    std::map<int, Connection*> _connections;
    std::map<int, std::string> _fdType;  // "listen", "client", "cgi"
    std::map<int, std::pair<std::string, std::string> > _listenAddrs;
    
    static const int TIMEOUT = 30;
    
public:
    WebServ(ServerConf& server) : _server(server) {}
    
    ~WebServ() {
        cleanup();
    }
    
    static bool startServer(ServerConf& server) {
        WebServ webserv(server);
        
        if (!webserv.setupListeners()) {
            std::cerr << "Failed to setup listeners\n";
            return false;
        }
        
        std::cout << "Document root: " << server.getRoot() << std::endl;
        std::cout << "Press Ctrl-C to quit.\n";
        
        webserv.run();
        return true;
    }
    
private:
    bool setupListeners() {
        std::vector<std::pair<std::string, std::string> > listens = _server.getListen();
        
        for (size_t i = 0; i < listens.size(); ++i) {
            try {
                int fd = Socket::StartSocket(listens[i].first, listens[i].second);
                addPollFd(fd, POLLIN);
                _fdType[fd] = "listen";
                _listenAddrs[fd] = listens[i];
                
                std::cout << "Listening on " << listens[i].first 
                         << ":" << listens[i].second << std::endl;
            } catch (const std::exception& e) {
                std::cerr << "Error: " << e.what() << std::endl;
            }
        }
        
        return !_pollfds.empty();
    }
    
    void run() {
        while (_runServer) {
            int n = poll(&_pollfds[0], _pollfds.size(), 1000);
            
            if (n < 0) {
                if (errno == EINTR) {
                    if (!_runServer) break;
                    continue;
                }
                std::cerr << "Poll error\n";
                break;
            }
            
            cleanupTimeouts();
            
            // Process events backwards for safe removal
            for (int i = static_cast<int>(_pollfds.size()) - 1; i >= 0; --i) {
                if (_pollfds[i].revents == 0) continue;
                
                int fd = _pollfds[i].fd;
                std::string type = _fdType[fd];
                
                // Handle errors first
                if (_pollfds[i].revents & (POLLERR | POLLHUP | POLLNVAL)) {
                    if (type != "listen") {
                        closeConnection(fd);
                    }
                    continue;
                }
                
                // Handle events by type
                if (type == "listen") {
                    if (_pollfds[i].revents & POLLIN) {
                        acceptConnection(fd);
                    }
                }
                else if (type == "client") {
                    Connection* conn = _connections[fd];
                    if (!conn) continue;
                    
                    if (_pollfds[i].revents & POLLIN) {
                        if (!handleRead(conn, i)) continue;
                    }
                    
                    if (_pollfds[i].revents & POLLOUT) {
                        if (!handleWrite(conn)) {
                            closeConnection(fd);
                        }
                    }
                }
                else if (type == "cgi") {
                    Connection* conn = _connections[fd];
                    if (conn) {
                        handleCGIRead(conn);
                    }
                }
            }
        }
        
        cleanup();
        std::cout << "Server closed.\n";
    }
    
    void acceptConnection(int listen_fd) {
        try {
            std::pair<std::string, std::string> addr = _listenAddrs[listen_fd];
            Connection* conn = new Connection(listen_fd, _server, addr.first, addr.second);
            
            int client_fd = conn->getFd();
            _connections[client_fd] = conn;
            _fdType[client_fd] = "client";
            addPollFd(client_fd, POLLIN | POLLOUT);
            
        } catch (const std::exception& e) {
            std::cerr << "Accept error: " << e.what() << std::endl;
        }
    }
    
    bool handleRead(Connection* conn, int poll_idx) {
        if (!conn->readRequest()) {
            closeConnection(conn->getFd());
            return false;
        }
        
        if (conn->isDone()) {
            // Request complete, check if CGI
            if (conn->needsCGI()) {
                int cgi_fd = conn->getCgiFd();
                if (cgi_fd > 0) {
                    _connections[cgi_fd] = conn;
                    _fdType[cgi_fd] = "cgi";
                    addPollFd(cgi_fd, POLLIN);
                }
            }
            
            // Remove POLLIN since request is complete
            _pollfds[poll_idx].events &= ~POLLIN;
        }
        
        return true;
    }
    
    bool handleWrite(Connection* conn) {
        if (!conn->isDone()) return true;
        
        // Wait for CGI if needed
        if (conn->needsCGI() && !conn->cgiDone()) {
            return true;
        }
        
        if (!conn->writeResponse()) {
            return false;
        }
        
        if (conn->isResponseDone()) {
            return false;  // Close connection
        }
        
        return true;
    }
    
    void handleCGIRead(Connection* conn) {
        conn->readCGIOutput();
        
        if (conn->cgiDone()) {
            // CGI complete, remove CGI fd from poll
            int cgi_fd = conn->getCgiFd();
            removePollFd(cgi_fd);
            _fdType.erase(cgi_fd);
            _connections.erase(cgi_fd);
        }
    }
    
    void closeConnection(int fd) {
        std::map<int, Connection*>::iterator it = _connections.find(fd);
        if (it == _connections.end()) return;
        
        Connection* conn = it->second;
        
        // Clean up CGI if present
        if (conn->needsCGI()) {
            int cgi_fd = conn->getCgiFd();
            if (cgi_fd > 0) {
                close(cgi_fd);
                removePollFd(cgi_fd);
                _fdType.erase(cgi_fd);
                _connections.erase(cgi_fd);
            }
        }
        
        close(fd);
        removePollFd(fd);
        _fdType.erase(fd);
        _connections.erase(it);
        delete conn;
    }
    
    void cleanupTimeouts() {
        time_t now = time(NULL);
        std::vector<int> expired;
        
        for (std::map<int, Connection*>::iterator it = _connections.begin();
             it != _connections.end(); ++it) {
            
            if (_fdType[it->first] == "listen") continue;
            if (_fdType[it->first] == "cgi") continue;
            
            if (now - it->second->getTime() > TIMEOUT) {
                expired.push_back(it->first);
            }
        }
        
        for (size_t i = 0; i < expired.size(); ++i) {
            std::cout << "Timeout: closing fd " << expired[i] << std::endl;
            closeConnection(expired[i]);
        }
    }
    
    void cleanup() {
        for (size_t i = 0; i < _pollfds.size(); ++i) {
            close(_pollfds[i].fd);
        }
        _pollfds.clear();
        
        for (std::map<int, Connection*>::iterator it = _connections.begin();
             it != _connections.end(); ++it) {
            delete it->second;
        }
        _connections.clear();
    }
    
    void addPollFd(int fd, short events) {
        struct pollfd pfd;
        pfd.fd = fd;
        pfd.events = events;
        pfd.revents = 0;
        _pollfds.push_back(pfd);
    }
    
    void removePollFd(int fd) {
        for (size_t i = 0; i < _pollfds.size(); ++i) {
            if (_pollfds[i].fd == fd) {
                _pollfds.erase(_pollfds.begin() + i);
                break;
            }
        }
    }
};

#endif


#ifndef CONNECTION_HPP
#define CONNECTION_HPP

#include <string>
#include <sys/socket.h>
#include <netinet/in.h>
#include <fcntl.h>
#include <unistd.h>
#include <ctime>
#include "Request.hpp"
#include "Response.hpp"
#include "CGI.hpp"
#include "ServerConf.hpp"

class Connection {
private:
    int _fd;
    time_t _time;
    ServerConf _server;
    
    std::string _host;
    std::string _port;
    std::string _read_buf;
    std::string _write_buf;
    size_t _write_pos;
    
    Request _request;
    Response _response;
    CGI _cgi;
    
    bool _request_done;
    bool _response_done;
    
public:
    Connection(int listen_fd, ServerConf& server, 
               const std::string& host, const std::string& port)
        : _fd(-1), _time(time(NULL)), _server(server), 
          _host(host), _port(port), _write_pos(0),
          _request_done(false), _response_done(false) {
        
        struct sockaddr_in addr;
        socklen_t len = sizeof(addr);
        _fd = accept(listen_fd, (struct sockaddr*)&addr, &len);
        
        if (_fd < 0) {
            throw std::runtime_error("Accept failed");
        }
        
        if (fcntl(_fd, F_SETFL, O_NONBLOCK) < 0) {
            close(_fd);
            throw std::runtime_error("fcntl failed");
        }
    }
    
    ~Connection() {
        if (_fd > 0) close(_fd);
    }
    
    int getFd() const { return _fd; }
    time_t getTime() const { return _time; }
    bool isDone() const { return _request_done; }
    bool isResponseDone() const { return _response_done; }
    bool needsCGI() const { return _request.isCGI() && _request.getStatusCode() == 200; }
    bool cgiDone() const { return _cgi.readDone(); }
    int getCgiFd() const { return _cgi.getFd(); }
    
    bool readRequest() {
        char buf[4096];
        ssize_t n = read(_fd, buf, sizeof(buf));
        
        if (n < 0) {
            if (errno == EAGAIN || errno == EWOULDBLOCK) {
                return true;
            }
            return false;
        }
        
        if (n == 0) {
            _request.parseRequest();  // EOF
        } else {
            _read_buf.append(buf, n);
            _request.parseRequest(_read_buf);
            _read_buf.clear();
        }
        
        touch();
        
        if (_request.isDone()) {
            _request_done = true;
            processRequest();
        }
        
        return true;
    }
    
    void processRequest() {
        _request.processRequest();
        
        if (needsCGI() && !_cgi.execDone()) {
            try {
                _cgi.executeCGI(_request, _server);
            } catch (const std::exception& e) {
                _request.setStatusCode(500);
                _request.CGIError();
                std::cerr << "CGI error: " << e.what() << std::endl;
            }
        }
        
        logRequest();
    }
    
    void readCGIOutput() {
        _cgi.readOutput();
        touch();
    }
    
    bool writeResponse() {
        if (_write_buf.empty()) {
            prepareResponse();
        }
        
        if (_write_buf.empty()) return false;
        
        const char* data = _write_buf.c_str() + _write_pos;
        size_t remaining = _write_buf.size() - _write_pos;
        
        ssize_t n = write(_fd, data, remaining);
        
        if (n < 0) {
            if (errno == EAGAIN || errno == EWOULDBLOCK) {
                return true;
            }
            return false;
        }
        
        _write_pos += n;
        touch();
        
        if (_write_pos >= _write_buf.size()) {
            _response_done = true;
        }
        
        return true;
    }
    
private:
    void touch() {
        _time = time(NULL);
    }
    
    void prepareResponse() {
        std::string redirect = checkRedirect();
        
        if (!redirect.empty()) {
            _response.setRedirect(301, redirect);
        }
        else if (needsCGI() && cgiDone()) {
            _response.fromCGI(_cgi.getOutput());
        }
        else if (_request.getStatusCode() != 200) {
            _response.setError(_request.getStatusCode(), _request.getMessage());
        }
        else if (_request.getStrMethod() == "GET") {
            _response.handleGet(_request, _server);
        }
        else if (_request.getStrMethod() == "POST") {
            _response.handlePost(_request, _server);
        }
        else if (_request.getStrMethod() == "DELETE") {
            _response.handleDelete(_request, _server);
        }
        else {
            _response.setError(405, "Method Not Allowed");
        }
        
        _write_buf = _response.build();
        _write_pos = 0;
    }
    
    std::string checkRedirect() {
        std::string uri = _request.getUri();
        std::map<std::string, LocationConf> locations = _server.getLocations();
        
        std::string best_match;
        const LocationConf* best_location = NULL;
        
        for (std::map<std::string, LocationConf>::const_iterator it = locations.begin();
             it != locations.end(); ++it) {
            if (uri.find(it->first) == 0 && it->first.length() > best_match.length()) {
                best_match = it->first;
                best_location = &(it->second);
            }
        }
        
        if (best_location) {
            return best_location->getRedirectUrl();
        }
        
        return "";
    }
    
    void logRequest() {
        time_t now = time(NULL);
        struct tm* t = localtime(&now);
        char buf[80];
        strftime(buf, sizeof(buf), "[%a %b %d %H:%M:%S %Y]", t);
        
        std::cout << buf << " [" << _host << "]:" << _port 
                  << " [" << _request.getStatusCode() << "]: "
                  << _request.getStrMethod() << " " << _request.getUri()
                  << " HTTP/1.1" << std::endl;
    }
};

#endif